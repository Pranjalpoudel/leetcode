class Solution(object):
    def pyramidTransition(self, bottom, allowed):
      
        from collections import defaultdict
        
        # Map each pair to the list of possible blocks above it
        allowed_map = defaultdict(list)
        for triple in allowed:
            allowed_map[triple[:2]].append(triple[2])
        
        # DFS function to build pyramid
        def dfs(row):
            if len(row) == 1:
                return True  # Reached the top
            # Generate all possible next rows
            options = ['']
            for i in range(len(row) - 1):
                pair = row[i:i+2]
                if pair not in allowed_map:
                    return False
                options = [prev + c for prev in options for c in allowed_map[pair]]
            # Try each possible next row
            return any(dfs(next_row) for next_row in options)
        
        return dfs(bottom)

        
